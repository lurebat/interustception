// Copyright (c) Microsoft Corporation.
// License: MIT OR Apache-2.0

use wdk::{nt_success, paged_code, println};
use wdk_sys::{NTSTATUS, WDFDEVICE_INIT, *};

use crate::{
    queue::echo_queue_initialize,
    queue_get_context,
    wdf_object_context::*,
    DeviceContext,
    GUID_DEVINTERFACE_ECHO,
    WDF_REQUEST_CONTEXT_TYPE_INFO,
    *,
};

/// Worker routine called to create a device and its software resources.
///
/// # Arguments:
///
/// * `device_init` - Pointer to an opaque init structure. Memory for this
///   structure will be freed by the framework when the WdfDeviceCreate
///   succeeds. So don't access the structure after that point.
///
/// # Return value:
///
/// * `NTSTATUS`
#[link_section = "PAGE"]
pub(crate) fn echo_device_create(mut device_init: &mut WDFDEVICE_INIT) -> NTSTATUS {
    paged_code!();
    
    macros::call_unsafe_wdf_function_binding!(
        WdfFdoInitSetFilter,
        device_init
    );
    
    macros::call_unsafe_wdf_function_binding!(
        WdfDeviceInitSetDeviceType,
        device_init,
        FILE_DEVICE_KEYBOARD
    );
    
    let mut attributes = WDF_OBJECT_ATTRIBUTES {
        ..WDF_OBJECT_ATTRIBUTES::default()
    };
    
    macros::call_unsafe_wdf_function_binding!(
        WDF_OBJECT_ATTRIBUTES_INIT,
        &mut device_init
    );
    
    attributes.ContextTypeInfo =  wdf_get_context_type_info!(DeviceContext);


    let mut device = WDF_NO_HANDLE as WDFDEVICE;
    let mut nt_status = unsafe {
        macros::call_unsafe_wdf_function_binding!(
            WdfDeviceCreate,
            (core::ptr::addr_of_mut!(device_init)) as *mut *mut WDFDEVICE_INIT,
            &mut attributes,
            &mut device,
        )
    };
    
    if !nt_success(nt_status) {
        println!("Error: WdfDeviceCreate failed {nt_status:#010X}");
        return nt_status;
    }

    // Get the device context and initialize it. WdfObjectGet_DEVICE_CONTEXT is an
    // inline function generated by WDF_DECLARE_CONTEXT_TYPE macro in the
    // device.h header file. This function will do the type checking and return
    // the device context. If you pass a wrong object  handle
    // it will return NULL and assert if run under framework verifier mode.


    // Create a device interface so that application can find and talk
    // to us.
    nt_status = unsafe {
        macros::call_unsafe_wdf_function_binding!(
                WdfDeviceCreateDeviceInterface,
                device,
                &GUID_DEVINTERFACE_ECHO,
                core::ptr::null_mut(),
            )
    };
    
if !nt_success(nt_status) {
        println!("Error: WdfDeviceCreateDeviceInterface failed {nt_status:#010X}");
        return nt_status;
    }

    let mut queue= WDFQUEUE {
        ..WDFQUEUE::default()
    };

    // Configure a default queue so that requests that are not
    // configure-fowarded using WdfDeviceConfigureRequestDispatching to goto
    // other queues get dispatched here.
    let mut queue_config = WDF_IO_QUEUE_CONFIG {
        Size: core::mem::size_of::<WDF_IO_QUEUE_CONFIG>() as ULONG,
        PowerManaged: _WDF_TRI_STATE::WdfUseDefault,
        DefaultQueue: true as u8,
        DispatchType: _WDF_IO_QUEUE_DISPATCH_TYPE::WdfIoQueueDispatchParallel,
        EvtIoInternalDeviceControl: Some(do_ioctl),
        ..WDF_IO_QUEUE_CONFIG::default()
    };

    // Create queue.
    let nt_status = unsafe {
        macros::call_unsafe_wdf_function_binding!(
            WdfIoQueueCreate,
            device,
            &mut queue_config,
            WDF_NO_OBJECT_ATTRIBUTES,
            &mut queue
        )
    };

    if !nt_success(nt_status) {
        println!("WdfIoQueueCreate failed {nt_status:#010X}");
        return nt_status;
    }


    let device_context: *mut DeviceContext =
        unsafe { wdf_object_get_device_context(device as WDFOBJECT) };
    unsafe { (*device_context).queue = queue };


    nt_status
}

/// This event is called by the Framework when the device is started
/// or restarted after a suspend operation.
///
/// This function is not marked pageable because this function is in the
/// device power up path. When a function is marked pagable and the code
/// section is paged out, it will generate a page fault which could impact
/// the fast resume behavior because the client driver will have to wait
/// until the system drivers can service this page fault.
///
/// # Arguments:
///
/// * `device` - Handle to a framework device object.
///
/// # Return value:
///
/// * `NTSTATUS` - Failures will result in the device stack being torn down.
extern "C" fn echo_evt_device_self_managed_io_start(device: WDFDEVICE) -> NTSTATUS {
    // Restart the queue and the periodic timer. We stopped them before going
    // into low power state.
    let queue: WDFQUEUE;

    println!("--> EchoEvtDeviceSelfManagedIoInit");

    unsafe {
        queue = macros::call_unsafe_wdf_function_binding!(WdfDeviceGetDefaultQueue, device);
    };

    let queue_context = unsafe { queue_get_context(queue as WDFOBJECT) };

    // Restart the queue and the periodic timer. We stopped them before going
    // into low power state.
    let [()] = [unsafe { macros::call_unsafe_wdf_function_binding!(WdfIoQueueStart, queue) }];

    let due_time: i64 = -(100) * (10000);

    let _ = unsafe { (*queue_context).timer.start(due_time) };

    println!("<-- EchoEvtDeviceSelfManagedIoInit");

    STATUS_SUCCESS
}

/// This event is called by the Framework when the device is stopped
/// for resource rebalance or suspended when the system is entering
/// Sx state.
///
/// # Arguments:
///
/// * `device` - Handle to a framework device object.
///
/// # Return value:
///
/// * `NTSTATUS` - The driver is not allowed to fail this function.  If it does,
///   the device stack will be torn down.
#[link_section = "PAGE"]
unsafe extern "C" fn echo_evt_device_self_managed_io_suspend(device: WDFDEVICE) -> NTSTATUS {
    paged_code!();

    println!("--> EchoEvtDeviceSelfManagedIoSuspend");

    // Before we stop the timer we should make sure there are no outstanding
    // i/o. We need to do that because framework cannot suspend the device
    // if there are requests owned by the driver. There are two ways to solve
    // this issue: 1) We can wait for the outstanding I/O to be complete by the
    // periodic timer 2) Register EvtIoStop callback on the queue and acknowledge
    // the request to inform the framework that it's okay to suspend the device
    // with outstanding I/O. In this sample we will use the 1st approach
    // because it's pretty easy to do. We will restart the queue when the
    // device is restarted.
    let queue =
        unsafe { macros::call_unsafe_wdf_function_binding!(WdfDeviceGetDefaultQueue, device) };
    let queue_context = unsafe { queue_get_context(queue as WDFOBJECT) };

    unsafe {
        let [()] = [macros::call_unsafe_wdf_function_binding!(
            WdfIoQueueStopSynchronously,
            queue
        )];
        // Stop the watchdog timer and wait for DPC to run to completion if it's already
        // fired.
        let _ = (*queue_context).timer.stop(true);
    };

    println!("<-- EchoEvtDeviceSelfManagedIoSuspend");

    STATUS_SUCCESS
}